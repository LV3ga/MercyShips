setwd("C:\CodingProjects\DS\Datasets")
setwd("CodingProjects\DS\Datasets")
setwd("C:\\CodingProjects\\DS\\Datasets")
read.table("Apple Dataset.csv")
read.table("AppleDataset.csv")
read.csv("AppleDataset.csv")
apple <- read.csv("AppleDataset.csv")
apple
nrow(apple)
max(apple$Date)
max(apple$Opem)
max(apple$Open)
max(apple$Close)
apple_new <- apple["Date" >  "2021-1-1"]
apple_new
rm(apple_new)
apple_new <- apple[which("Date" >  "2021-1-1"),]
apple_new
rm(apple_new)
apple_new <- apple[which(apple$Date >  "2021-1-1"),]
apple_new
apple_new <- apple[which(apple$Date >  "2021-01-01"),]
apple_new
apple_new <- apple[which(apple$Date >  "2022-01-01"),]
apple_new
apple_new_diff <- apple$Open - apple$Close
apple_new_diff
apple_new_diff
apple_new
apple_new_diff <- apple$Close - apple$Open
apple_new_diff
########################################################
#Spatial Autocorrelation (manual)
########################################################
library(raster)
#  raster comes with datasets
p <- shapefile(system.file("external/lux.shp", package = "raster"))
#  include rows where NAME_1 == "Diekrich"
p_Diekirch <- p[p$NAME_1=="Diekirch",]
#  create new column called value
p_Diekirch$value <- c(10, 6, 4, 11, 6)
data.frame(p_Diekirch)
#  Let's investigate spatial autocorrelation for variable AREA
#  "Are adjacent/close regions of similar size?
#   We will go through the process manually first
par(mai=c(0,0,0,0))
plot(p_Diekirch, col=2:7)
xy <- coordinates(p_Diekirch)
points(xy, cex=6, pch=20, col='white')
text(p_Diekirch, 'ID_2', cex=1.5)
#  Let's investigate spatial autocorrelation for variable AREA
#  "Are adjacent/close regions of similar size?
#   We will go through the process manually first
par(mai=c(0,0,0,0))
plot(p_Diekirch, col=2:7)
xy <- coordinates(p_Diekirch)
points(xy, cex=6, pch=20, col='white')
text(p_Diekirch, 'value', cex=1.5)
mean(c(10, 6, 4, 11, 6))
var(c(4,2,4,2,4))
?var
var(c(4,2,4,2,2))
cor(c(4,2,4,2,4), c(2,4,2,4,2))
#  Let's investigate spatial autocorrelation for variable AREA
#  "Are adjacent/close regions of similar size?
#   We will go through the process manually first
par(mai=c(0,0,0,0))
plot(p_Diekirch, col=2:7)
xy <- coordinates(p_Diekirch)
points(xy, cex=6, pch=20, col='white')
text(p_Diekirch, 'value', cex=1.5)
#  Now we define what polygons are "near"
#  We'll use adjacency as a criterion
library(spdep)
#  Using binary for TRUE/FALSE distance, as we are only considering adjacency
ww <- nb2listw(w, style='B')
w <- poly2nb(p_Diekirch, row.names = p_Diekirch$Id)
class(w)
summary(w)
#  Using binary for TRUE/FALSE distance, as we are only considering adjacency
ww <- nb2listw(w, style='B')
#  Use the moran function to compute Moran's I
moran(p_Diekirch$value, ww, n=length(ww$neighbours), S0 = Szero(ww))
#  Here we run our MC simulation. Here we do 99 iterations.
moran.mc(p_Diekirch$value, ww, nsim=99)
data.frame(p_Diekirch)
text(p_Diekirch, 'ID_2', cex=1.5)
#  Let's investigate spatial autocorrelation for value
#  "Do adjacent regions affect each other?
#  We will go through the process manually first
par(mai=c(0,0,0,0))
plot(p_Diekirch, col=2:7)
xy <- coordinates(p_Diekirch)
points(xy, cex=6, pch=20, col='white')
text(p_Diekirch, 'ID_2', cex=1.5)
p_Diekirch$value <- c(9, 9, 6, 11, 7)
data.frame(p_Diekirch)
#  Let's investigate spatial autocorrelation for value
#  "Do adjacent regions affect each other?
#  We will go through the process manually first
par(mai=c(0,0,0,0))
plot(p_Diekirch, col=2:7)
xy <- coordinates(p_Diekirch)
points(xy, cex=6, pch=20, col='white')
text(p_Diekirch, 'ID_2', cex=1.5)
#  Using binary for TRUE/FALSE distance, as we are only considering adjacency
ww <- nb2listw(w, style='B')
#  Use the moran function to compute Moran's I
moran(p_Diekirch$value, ww, n=length(ww$neighbours), S0 = Szero(ww))
#  Here we run our MC simulation. Here we do 99 iterations.
moran.mc(p_Diekirch$value, ww, nsim=99)
w <- poly2nb(p_Diekirch, row.names = p_Diekirch$Id)
class(w)
summary(w)
#  Using binary for TRUE/FALSE distance, as we are only considering adjacency
ww <- nb2listw(w, style='B')
#  Use the moran function to compute Moran's I
moran(p_Diekirch$value, ww, n=length(ww$neighbours), S0 = Szero(ww))
#  Here we run our MC simulation. Here we do 99 iterations.
moran.mc(p_Diekirch$value, ww, nsim=99)
p_Diekirch$value <- c(80, 90, 65, 100, 70)
data.frame(p_Diekirch)
w <- poly2nb(p_Diekirch, row.names = p_Diekirch$Id)
class(w)
summary(w)
#  Using binary for TRUE/FALSE distance, as we are only considering adjacency
ww <- nb2listw(w, style='B')
#  Use the moran function to compute Moran's I
moran(p_Diekirch$value, ww, n=length(ww$neighbours), S0 = Szero(ww))
#  Here we run our MC simulation. Here we do 99 iterations.
moran.mc(p_Diekirch$value, ww, nsim=99)
data.frame(p_Diekirch)
p_Diekirch$value <- c(80, 90, 65, 100, 70)
data.frame(p_Diekirch)
w <- poly2nb(p_Diekirch, row.names = p_Diekirch$Id)
class(w)
summary(w)
#  Now let's plot the links between polygons
plot(p_Diekirch, col='gray', border='blue', lwd=2)
plot(w, xy, col='red', lwd=2, add=TRUE)
#  Transform w into spatial weights matrix
#  Since we are only considering adjacency, w will be a simple binary matrix
wm <- nb2mat(w, style='B')
wm
w
#  Now we can compute Moran's I (statistic measuring spatial correlation)
n <- length(p_Diekirch)
y <- p_Diekirch$value
ybar <- mean(y)
dy <- y - ybar
g <- expand.grid(dy, dy)
yiyj <- g[,1] * g[,2]
pm <- matrix(yiyj, ncol=n)
pm
#  NOTE THIS IS NOT MATRIX MULTIPLICATION
pmw <- pm * wm
spmw <- sum(pmw)
spmw
smw <- sum(wm)
sw <- spmw /smw
vr <- n / sum(dy^2)
MI <- vr * sw
MI
